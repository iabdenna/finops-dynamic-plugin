/**
  OpenShift Dynamic Plugin SDK
  https://github.com/openshift/dynamic-plugin-sdk

  packageName    : @openshift/dynamic-plugin-sdk-webpack
  packageVersion : 4.0.2
  buildDate      : March 5, 2024
  buildTime      : 7:29:28 PM GMT+1
  gitCommit      : 85cdc2b393f4686325a02a0841d534a1cd575210
  gitBranch      : main
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var yup = require('yup');
var identity = require('lodash/identity');
var isEmpty = require('lodash/isEmpty');
var mapValues = require('lodash/mapValues');
var semver = require('semver');
var webpack = require('webpack');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var yup__namespace = /*#__PURE__*/_interopNamespace(yup);
var identity__default = /*#__PURE__*/_interopDefaultLegacy(identity);
var isEmpty__default = /*#__PURE__*/_interopDefaultLegacy(isEmpty);
var mapValues__default = /*#__PURE__*/_interopDefaultLegacy(mapValues);
var semver__namespace = /*#__PURE__*/_interopNamespace(semver);

const DEFAULT_REMOTE_ENTRY_CALLBACK = '__load_plugin_entry__';

// TODO(vojtech): suppress false positive https://github.com/jsx-eslint/eslint-plugin-react/pull/3326
/**
 * Schema for a valid semver string.
 *
 * @see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
 */
const semverStringSchema = yup__namespace
    .string()
    .required()
    .matches(/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/);
/**
 * Schema for a valid plugin name.
 *
 * @example
 * ```
 * foo
 * foo-bar
 * foo.bar
 * foo.bar-Test
 * Foo-Bar-abc.123
 * ```
 */
const pluginNameSchema = yup__namespace
    .string()
    .required()
    .matches(/^[a-zA-Z]+(?:[-.]?[a-zA-Z0-9]+)*$/);
/**
 * Schema for a valid extension type.
 *
 * @example
 * ```
 * app.foo
 * app.foo-bar
 * app.foo/bar
 * My-app.Foo-Bar
 * My-app.Foo-Bar/abcTest
 * ```
 */
const extensionTypeSchema = yup__namespace
    .string()
    .required()
    .matches(/^[a-zA-Z]+(?:-[a-zA-Z]+)*\.[a-zA-Z]+(?:-[a-zA-Z]+)*(?:\/[a-zA-Z]+(?:-[a-zA-Z]+)*)*$/);
/**
 * Schema for a valid feature flag name.
 *
 * @example
 * ```
 * FOO
 * FOO_BAR
 * FOO_BAR123
 * ```
 */
const featureFlagNameSchema = yup__namespace
    .string()
    .required()
    .matches(/^[A-Z]+[A-Z0-9_]*$/);
/**
 * Schema for `Extension` objects.
 */
const extensionSchema = yup__namespace
    .object()
    .required()
    .shape({
    type: extensionTypeSchema,
    properties: yup__namespace.object().required(),
    flags: yup__namespace.object().shape({
        required: yup__namespace.array().of(featureFlagNameSchema),
        disallowed: yup__namespace.array().of(featureFlagNameSchema),
    }),
});
/**
 * Schema for an array of `Extension` objects.
 */
const extensionArraySchema = yup__namespace.array().of(extensionSchema).required();
/**
 * Schema for `PluginRegistrationMethod` objects.
 */
const pluginRegistrationMethodSchema = yup__namespace
    .mixed()
    .oneOf(['callback', 'custom'])
    .required();
/**
 * Schema for `PluginRuntimeMetadata` objects.
 */
const pluginRuntimeMetadataSchema = yup__namespace.object().required().shape({
    name: pluginNameSchema,
    version: semverStringSchema,
    // TODO(vojtech): Yup lacks native support for map-like structures with arbitrary keys
    // TODO(vojtech): we need to validate dependency values as semver ranges
    dependencies: yup__namespace.object(),
    customProperties: yup__namespace.object(),
});
/**
 * Schema for `PluginManifest` objects.
 */
pluginRuntimeMetadataSchema.shape({
    baseURL: yup__namespace.string().required(),
    extensions: extensionArraySchema,
    loadScripts: yup__namespace.array().of(yup__namespace.string().required()).required(),
    registrationMethod: pluginRegistrationMethodSchema,
    buildHash: yup__namespace.string(),
});

/**
 * Schema for `PluginBuildMetadata` objects.
 */
const pluginBuildMetadataSchema = pluginRuntimeMetadataSchema.shape({
    // TODO(vojtech): Yup lacks native support for map-like structures with arbitrary keys
    exposedModules: yup__namespace.object(),
});
/**
 * Schema for `PluginModuleFederationSettings` objects.
 */
const pluginModuleFederationSettingsSchema = yup__namespace.object().required().shape({
    libraryType: yup__namespace.string(),
    sharedScopeName: yup__namespace.string(),
});
/**
 * Schema for `PluginEntryCallbackSettings` objects.
 */
const pluginEntryCallbackSettingsSchema = yup__namespace.object().required().shape({
    name: yup__namespace.string(),
    pluginID: yup__namespace.string(),
});
/**
 * Schema for adapted `DynamicRemotePluginOptions` objects.
 */
const dynamicRemotePluginAdaptedOptionsSchema = yup__namespace.object().required().shape({
    pluginMetadata: pluginBuildMetadataSchema,
    extensions: extensionArraySchema,
    sharedModules: yup__namespace.object().required(),
    moduleFederationSettings: pluginModuleFederationSettingsSchema,
    entryCallbackSettings: pluginEntryCallbackSettingsSchema,
    entryScriptFilename: yup__namespace.string().required(),
    pluginManifestFilename: yup__namespace.string().required(),
});

const findPluginChunks = (containerName, compilation) => {
    const allChunks = Array.from(compilation.chunks);
    const entryChunk = allChunks.find((chunk) => chunk.name === containerName);
    if (!entryChunk) {
        throw new Error(`Cannot find entry chunk ${containerName}`);
    }
    if (entryChunk.hasRuntime()) {
        return { entryChunk };
    }
    const runtimeChunk = allChunks.find((chunk) => chunk.name === entryChunk.runtime);
    if (!runtimeChunk) {
        throw new Error(`Cannot find runtime chunk for entry chunk ${containerName}`);
    }
    return { entryChunk, runtimeChunk };
};
const getChunkFiles = (chunk, compilation, includeFile = (assetInfo) => !assetInfo.development && !assetInfo.hotModuleReplacement) => Array.from(chunk.files).filter((fileName) => {
    const assetInfo = compilation.assetsInfo.get(fileName);
    if (!assetInfo) {
        throw new Error(`Missing asset information for ${fileName}`);
    }
    return includeFile(assetInfo);
});

class GenerateManifestPlugin {
    constructor(options) {
        this.options = options;
    }
    apply(compiler) {
        const { containerName, manifestFilename, manifestData, transformManifest } = this.options;
        const { publicPath } = compiler.options.output;
        if (!publicPath) {
            throw new Error('output.publicPath option must be set to ensure plugin assets are loaded properly in the browser');
        }
        compiler.hooks.thisCompilation.tap(GenerateManifestPlugin.name, (compilation) => {
            compilation.hooks.processAssets.tap({
                name: GenerateManifestPlugin.name,
                // Using one of the later asset processing stages to ensure all assets
                // are already added and optimized within the given webpack compilation
                stage: webpack.Compilation.PROCESS_ASSETS_STAGE_ANALYSE,
            }, () => {
                const { entryChunk, runtimeChunk } = findPluginChunks(containerName, compilation);
                const pluginChunks = runtimeChunk ? [runtimeChunk, entryChunk] : [entryChunk];
                const loadScripts = pluginChunks.reduce((acc, chunk) => [...acc, ...getChunkFiles(chunk, compilation)], []);
                const manifest = transformManifest({
                    ...manifestData,
                    baseURL: compilation.getAssetPath(publicPath, {}),
                    loadScripts,
                    buildHash: compilation.fullHash,
                });
                const manifestContent = JSON.stringify(manifest, null, compiler.options.mode === 'production' ? undefined : 2);
                compilation.emitAsset(manifestFilename, new webpack.sources.RawSource(Buffer.from(manifestContent)));
                const warnings = [];
                if (manifest.extensions.length === 0) {
                    warnings.push('Plugin has no extensions');
                }
                if (!manifest.baseURL.endsWith('/')) {
                    warnings.push('Plugin base URL (output.publicPath) should have a trailing slash');
                }
                warnings.forEach((message) => {
                    const error = new webpack.WebpackError(message);
                    error.file = manifestFilename;
                    compilation.warnings.push(error);
                });
            });
        });
    }
}

class PatchEntryCallbackPlugin {
    constructor(options) {
        this.options = options;
    }
    apply(compiler) {
        const { containerName, callbackName, pluginID } = this.options;
        compiler.hooks.thisCompilation.tap(PatchEntryCallbackPlugin.name, (compilation) => {
            compilation.hooks.processAssets.tap({
                name: PatchEntryCallbackPlugin.name,
                stage: webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE,
            }, () => {
                const { entryChunk } = findPluginChunks(containerName, compilation);
                getChunkFiles(entryChunk, compilation).forEach((fileName) => {
                    compilation.updateAsset(fileName, (source) => {
                        const newSource = new webpack.sources.ReplaceSource(source);
                        const fromIndex = source.source().toString().indexOf(`${callbackName}(`);
                        if (fromIndex >= 0) {
                            newSource.insert(fromIndex + callbackName.length + 1, `'${pluginID}', `);
                        }
                        else {
                            const error = new webpack.WebpackError(`Missing call to ${callbackName}`);
                            error.file = fileName;
                            error.chunk = entryChunk;
                            compilation.errors.push(error);
                        }
                        return newSource;
                    });
                });
            });
        });
    }
}

class ValidateCompilationPlugin {
    constructor(options) {
        this.options = options;
    }
    apply(compiler) {
        const { containerName, jsonpLibraryType } = this.options;
        compiler.hooks.done.tap(ValidateCompilationPlugin.name, ({ compilation }) => {
            const { runtimeChunk } = findPluginChunks(containerName, compilation);
            if (runtimeChunk) {
                const errorMessage = jsonpLibraryType
                    ? 'Detected separate runtime chunk while using jsonp library type.\n' +
                        'This configuration is not allowed since it will cause issues when reloading plugins at runtime.\n' +
                        'Please update your webpack configuration to avoid emitting a separate runtime chunk.'
                    : 'Detected separate runtime chunk while using non-jsonp library type.\n' +
                        'This configuration is not recommended since it may cause issues when reloading plugins at runtime.\n' +
                        'Consider updating your webpack configuration to avoid emitting a separate runtime chunk.';
                const error = new webpack.WebpackError(errorMessage);
                error.chunk = runtimeChunk;
                (jsonpLibraryType ? compilation.errors : compilation.warnings).push(error);
            }
        });
    }
}

const DEFAULT_MANIFEST = 'plugin-manifest.json';
const DEFAULT_ENTRY_SCRIPT = 'plugin-entry.js';
class DynamicRemotePlugin {
    constructor(options) {
        this.adaptedOptions = {
            pluginMetadata: options.pluginMetadata,
            extensions: options.extensions,
            sharedModules: options.sharedModules ?? {},
            moduleFederationSettings: options.moduleFederationSettings ?? {},
            entryCallbackSettings: options.entryCallbackSettings ?? {},
            entryScriptFilename: options.entryScriptFilename ?? DEFAULT_ENTRY_SCRIPT,
            pluginManifestFilename: options.pluginManifestFilename ?? DEFAULT_MANIFEST,
            transformPluginManifest: options.transformPluginManifest ?? identity__default["default"],
        };
        try {
            dynamicRemotePluginAdaptedOptionsSchema.validateSync(this.adaptedOptions, {
                strict: true,
                abortEarly: false,
            });
        }
        catch (e) {
            throw new Error(`Invalid ${DynamicRemotePlugin.name} options:\n` +
                e.errors.join('\n'));
        }
        // TODO(vojtech): remove this code once the validation library supports this natively
        const invalidDepNames = Object.entries(this.adaptedOptions.pluginMetadata.dependencies ?? {}).reduce((acc, [depName, versionRange]) => versionRange && semver__namespace.validRange(versionRange) ? acc : [...acc, depName], []);
        if (invalidDepNames.length > 0) {
            throw new Error(`Dependency values must be valid semver ranges: ${invalidDepNames.join(', ')}`);
        }
    }
    apply(compiler) {
        const { pluginMetadata, extensions, sharedModules, moduleFederationSettings, entryCallbackSettings, entryScriptFilename, pluginManifestFilename, transformPluginManifest, } = this.adaptedOptions;
        const containerName = pluginMetadata.name;
        const moduleFederationLibraryType = moduleFederationSettings.libraryType ?? 'jsonp';
        const moduleFederationSharedScope = moduleFederationSettings.sharedScopeName ?? 'default';
        const entryCallbackName = entryCallbackSettings.name ?? DEFAULT_REMOTE_ENTRY_CALLBACK;
        const entryCallbackPluginID = entryCallbackSettings.pluginID ?? pluginMetadata.name;
        const jsonp = moduleFederationLibraryType === 'jsonp';
        const containerLibrary = {
            type: moduleFederationLibraryType,
            name: jsonp ? entryCallbackName : containerName,
        };
        const containerModules = mapValues__default["default"](pluginMetadata.exposedModules ?? {}, (moduleRequest, moduleName) => ({
            import: moduleRequest,
            name: `exposed-${moduleName}`,
        }));
        // Assign a unique name for the webpack build
        compiler.options.output.uniqueName ??= containerName;
        // Generate webpack federated module container assets
        new webpack.container.ModuleFederationPlugin({
            name: containerName,
            library: containerLibrary,
            filename: entryScriptFilename,
            exposes: containerModules,
            shared: sharedModules,
            shareScope: moduleFederationSharedScope,
        }).apply(compiler);
        // ModuleFederationPlugin does not generate a container entry when the provided
        // exposes option is empty; we fix that by invoking the ContainerPlugin manually
        if (isEmpty__default["default"](containerModules)) {
            new webpack.container.ContainerPlugin({
                name: containerName,
                library: containerLibrary,
                filename: entryScriptFilename,
                exposes: containerModules,
                shareScope: moduleFederationSharedScope,
            }).apply(compiler);
        }
        // Generate plugin manifest
        new GenerateManifestPlugin({
            containerName,
            manifestFilename: pluginManifestFilename,
            manifestData: {
                name: pluginMetadata.name,
                version: pluginMetadata.version,
                dependencies: pluginMetadata.dependencies,
                customProperties: pluginMetadata.customProperties,
                extensions,
                registrationMethod: jsonp ? 'callback' : 'custom',
            },
            transformManifest: transformPluginManifest,
        }).apply(compiler);
        // Post-process container entry generated by ModuleFederationPlugin
        if (jsonp) {
            new PatchEntryCallbackPlugin({
                containerName,
                callbackName: entryCallbackName,
                pluginID: entryCallbackPluginID,
            }).apply(compiler);
        }
        // Validate webpack compilation
        new ValidateCompilationPlugin({ containerName, jsonpLibraryType: jsonp }).apply(compiler);
    }
}

exports.DynamicRemotePlugin = DynamicRemotePlugin;
