import * as ts from 'typescript';
/**
 * Maps each index module export to a dynamic module request (import specifier).
 */
export declare type DynamicModuleMap = {
    [exportName: string]: string;
};
/**
 * Map all exports of the given index module to their corresponding dynamic modules.
 *
 * Example: `@patternfly/react-core` package provides ESModules index at `dist/esm/index.js`
 * which exports Alert component related code & types via `dist/esm/components/Alert/index.js`
 * module.
 *
 * Given the example above, this function should return a mapping like so:
 * ```js
 * {
 *   Alert: 'dist/dynamic/components/Alert',
 *   AlertProps: 'dist/dynamic/components/Alert',
 *   AlertContext: 'dist/dynamic/components/Alert',
 *   // ...
 * }
 * ```
 *
 * The above mapping can be used when generating import statements like so:
 * ```ts
 * import { Alert } from '@patternfly/react-core/dist/dynamic/components/Alert';
 * ```
 *
 * It may happen that the same export is provided by multiple dynamic modules;
 * in such case, the resolution favors modules with most specific file paths, for example
 * `dist/dynamic/components/Wizard/hooks` is favored over `dist/dynamic/components/Wizard`.
 *
 * Dynamic modules nested under `deprecated` or `next` directories are ignored.
 *
 * If the referenced index module does not exist, an empty object is returned.
 */
export declare const getDynamicModuleMap: (basePath: string, indexModule?: string, resolutionField?: string, tsCompilerOptions?: ts.CompilerOptions) => DynamicModuleMap;
